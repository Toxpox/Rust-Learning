# Traits

Trait'ler, Rust'Ä±n en temel yapÄ± taÅŸlarÄ±ndan biridir. Bir trait, bir **davranÄ±ÅŸ sÃ¶zleÅŸmesi** tanÄ±mlar; herhangi bir veri yapÄ±sÄ± bu sÃ¶zleÅŸmeyi uygulayarak ilgili davranÄ±ÅŸlarÄ± kazanÄ±r. Sistem iÃ§inde ortak davranÄ±ÅŸlara sahip tipleri dÃ¼zenlemek, soyutlamak ve generic yapÄ±larla birlikte kullanmak iÃ§in kritik Ã¶neme sahiptir.

C# tarafÄ±ndaki **interface** kavramÄ±yla benzer bir amaca hizmet eder, ancak Rust trait'leri varsayÄ±lan implementasyon (default implementation) ve trait object gibi ek yetenekler sunar.

---

## 1) Trait TanÄ±mlama ve Uygulama

AÅŸaÄŸÄ±daki `Service` trait'i, bir servisin temel yaÅŸam dÃ¶ngÃ¼sÃ¼nÃ¼ tanÄ±mlar: aktif etme, deaktif etme ve durum sorgulama.

```rust
trait Service {
    fn activate(&mut self);
    fn deactivate(&mut self);
    fn status(&self) {
        println!("Service status");
    }
}
```

### AÃ§Ä±klama

- `activate` ve `deactivate` fonksiyonlarÄ± **gÃ¶vdesiz** tanÄ±mlanmÄ±ÅŸtÄ±r. Bu trait'i uygulayan her yapÄ± bu fonksiyonlarÄ± kendisi yazmak zorundadÄ±r.
- `status` fonksiyonu **varsayÄ±lan bir implementasyona** (default implementation) sahiptir. Uygulayan yapÄ± bu fonksiyonu ezebilir (override), ancak zorunlu deÄŸildir.

---

## 2) Trait'i FarklÄ± YapÄ±lara Uygulama

```rust
struct Redis;
struct HealthCheck {
    is_online: bool,
}

impl Service for Redis {
    fn activate(&mut self) {
        println!("Activating Redis");
    }
    fn deactivate(&mut self) {
        println!("Deactivating Redis");
    }
}

impl Service for HealthCheck {
    fn activate(&mut self) {
        self.is_online = true;
        println!("Activating HealthCheck");
    }
    fn deactivate(&mut self) {
        println!("Deactivating HealthCheck");
    }
    fn status(&self) {
        println!("Service status {}", self.is_online);
    }
}
```

### Ã–nemli noktalar

- `Redis` yapÄ±sÄ± `status` fonksiyonunu uygulamaz; dolayÄ±sÄ±yla trait'te tanÄ±mlÄ± varsayÄ±lan versiyon kullanÄ±lÄ±r.
- `HealthCheck` yapÄ±sÄ± `status` fonksiyonunu **override** ederek `is_online` alanÄ±nÄ± raporlar.
- Bir trait uygulandÄ±ÄŸÄ±nda, varsayÄ±lan implementasyona sahip olmayan tÃ¼m fonksiyonlar **zorunlu** olarak yazÄ±lmalÄ±dÄ±r. Aksi halde derleme hatasÄ± alÄ±nÄ±r.

---

## 3) Trait'i Fonksiyon Parametresi Olarak Kullanmak

Trait'ler, fonksiyon parametrelerinde tip kÄ±sÄ±tlamasÄ± olarak kullanÄ±labilir. Bunu yapmanÄ±n iki yolu vardÄ±r:

### `impl Trait` SÃ¶z Dizimi

```rust
fn start_sample(service: &mut impl Service) {
    service.activate();
    println!("{:?}", service.status());
    service.deactivate();
    println!("{:?}", service.status());
}
```

### Generic SÃ¶z Dizimi (Trait Bound)

```rust
fn start_sample2<T: Service>(service: &mut T) {
    service.activate();
    println!("{:?}", service.status());
    service.deactivate();
    println!("{:?}", service.status());
}
```

```rust
// KullanÄ±m
let mut redis_instance = Redis;
let mut doctor = HealthCheck { is_online: false };

start_sample(&mut redis_instance);
start_sample(&mut doctor);
start_sample2(&mut redis_instance);
```

### FarklarÄ±

| Ã–zellik | `impl Trait` | Generic `<T: Trait>` |
|---------|-------------|---------------------|
| Okunabilirlik | Daha kÄ±sa ve anlaÅŸÄ±lÄ±r | KarmaÅŸÄ±k kÄ±sÄ±tlamalarda daha esnek |
| Birden fazla parametre | Her parametre farklÄ± tÃ¼r olabilir | AynÄ± `T` ile zorlanabilir, farklÄ± aynÄ± olmalÄ±dÄ±r |
| Turbofish desteÄŸi | Yok | `start_sample2::<Redis>(...)` |
| KullanÄ±m alanÄ± | Basit senaryolar | Birden fazla trait bound veya tÃ¼r iliÅŸkisi gerektiÄŸinde |

> **Not:** `impl Trait` sÃ¶z dizimi, arka planda compiler tarafÄ±ndan generic'e dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼r. DolayÄ±sÄ±yla performans farkÄ± yoktur; tercih tamamen okunabilirlik ve esneklik ihtiyacÄ±na baÄŸlÄ±dÄ±r.

---

## 4) Default Trait Implementasyonu

Bir trait'te tanÄ±mlÄ± fonksiyonun gÃ¶vdesi varsa, bu fonksiyon **varsayÄ±lan davranÄ±ÅŸ** olarak kabul edilir. Uygulayan yapÄ±lar bu davranÄ±ÅŸÄ± olduÄŸu gibi kullanabilir veya kendi versiyonlarÄ±nÄ± yazabilir.

```rust
trait Payment {
    fn pay(&self, amount: f64) {
        println!("Paid amount {:.2} with cash.", amount);
    }
}

struct DebitCard;
impl Payment for DebitCard {}

struct CompanyAccount;
impl Payment for CompanyAccount {}

struct CreditCard;
impl Payment for CreditCard {
    fn pay(&self, amount: f64) {
        let amount_with_commission = amount * 1.1;
        println!("Paid {:.2} with credit card.", amount_with_commission);
    }
}
```

```rust
// KullanÄ±m
let debit_payment = DebitCard;
let company_payment = CompanyAccount;
let card_payment = CreditCard;

debit_payment.pay(100.0);   // "Paid amount 100.00 with cash."
card_payment.pay(100.0);    // "Paid 110.00 with credit card."
company_payment.pay(100.0); // "Paid amount 100.00 with cash."
```

### AÃ§Ä±klama

- `DebitCard` ve `CompanyAccount` varsayÄ±lan `pay` davranÄ±ÅŸÄ±nÄ± kullanÄ±r.
- `CreditCard` ise %10 komisyon ekleyerek kendi davranÄ±ÅŸÄ±nÄ± tanÄ±mlar.
- BoÅŸ `impl Payment for DebitCard {}` bloÄŸu, varsayÄ±lan implementasyonu kabul ettiÄŸini ifade eder.

### ğŸ”„ Alternatif YaklaÅŸÄ±m: Komisyon OranÄ±nÄ± Trait'te TanÄ±mlamak

FarklÄ± Ã¶deme tipleri iÃ§in farklÄ± komisyon oranlarÄ± gerekiyorsa, bu oran da trait'te bir metot olarak tanÄ±mlanabilir:

```rust
trait Payment {
    fn commission_rate(&self) -> f64 {
        0.0 // VarsayÄ±lan komisyon yok
    }

    fn pay(&self, amount: f64) {
        let total = amount * (1.0 + self.commission_rate());
        println!("Paid {:.2}", total);
    }
}

impl Payment for CreditCard {
    fn commission_rate(&self) -> f64 {
        0.10
    }
}
```

Bu yaklaÅŸÄ±mla `pay` mantÄ±ÄŸÄ± tek bir yerde kalÄ±r ve her yapÄ± yalnÄ±zca kendi komisyon oranÄ±nÄ± belirtir. **DRY** (Don't Repeat Yourself) prensibine daha uygundur.

---

## 5) Trait Object â€” `dyn Trait`

BazÄ± durumlarda, belirli bir trait'i uygulayan **farklÄ± tÃ¼rdeki nesneleri** aynÄ± koleksiyonda tutmak veya aynÄ± fonksiyona gÃ¶ndermek gerekebilir. Rust'ta farklÄ± tÃ¼rlerin bellekte farklÄ± boyutlarda yer kaplamasÄ± nedeniyle, bu nesnelerin boyutu derleme zamanÄ±nda bilinemez. Bu sorunu Ã§Ã¶zmek iÃ§in **trait object** (`dyn Trait`) kullanÄ±lÄ±r.

```rust
trait Draw {
    fn draw(&self);
}

struct Circle;
struct Square;
struct Player;

impl Draw for Circle {
    fn draw(&self) {
        println!("Drawing a circle");
    }
}

impl Draw for Square {
    fn draw(&self) {
        println!("Drawing a square");
    }
}

impl Draw for Player {
    fn draw(&self) {
        println!("Drawing a player");
    }
}
```

### Trait Object ile Fonksiyon Parametresi

```rust
fn draw_shapes(shapes: &Vec<&dyn Draw>) {
    for shape in shapes.iter() {
        shape.draw();
    }
}
```

```rust
// KullanÄ±m
let red_ball = Circle;
let blue_ball = Circle;
let wall = Square;
let warrior = Player;

let level_1: Vec<&dyn Draw> = vec![&red_ball, &blue_ball, &wall, &warrior];
draw_shapes(&level_1);
```

### AÃ§Ä±klama

- `&dyn Draw` bir **trait object**'tir. Derleyici, trait object aracÄ±lÄ±ÄŸÄ±yla hangi yapÄ±nÄ±n hangi `draw` metodunu Ã§aÄŸÄ±racaÄŸÄ±nÄ± **Ã§alÄ±ÅŸma zamanÄ±nda** (runtime) belirler. Buna **dynamic dispatch** denir.
- `Vec<&dyn Draw>`, `Draw` trait'ini uygulayan herhangi bir tÃ¼rÃ¼n referansÄ±nÄ± tutabilir. Bu sayede `Circle`, `Square` ve `Player` aynÄ± vektÃ¶rde bir arada bulunabilir.
- Trait object'ler her zaman bir referans (`&dyn`) veya akÄ±llÄ± pointer (`Box<dyn>`) arkasÄ±nda kullanÄ±lmalÄ±dÄ±r; Ã§Ã¼nkÃ¼ boyutlarÄ± derleme zamanÄ±nda bilinmez (unsized type).

### âš¡ Dynamic Dispatch vs. Static Dispatch

| Ã–zellik | Static Dispatch (`impl Trait` / Generic) | Dynamic Dispatch (`dyn Trait`) |
|---------|------------------------------------------|-------------------------------|
| Ã‡Ã¶zÃ¼mleme zamanÄ± | Derleme zamanÄ± (monomorphization) | Ã‡alÄ±ÅŸma zamanÄ± (vtable lookup) |
| Performans | Daha hÄ±zlÄ±, inline optimizasyona uygun | vtable indirection nedeniyle kÃ¼Ã§Ã¼k ek maliyet |
| Esneklik | Her Ã§aÄŸrÄ± tek bir tÃ¼r ile Ã§alÄ±ÅŸÄ±r | FarklÄ± tÃ¼rler aynÄ± koleksiyonda tutulabilir |
| Kod boyutu | Her tÃ¼r iÃ§in ayrÄ± kod Ã¼retilir | Tek bir fonksiyon kodu |

> **UyarÄ±:** Dynamic dispatch, performans aÃ§Ä±sÄ±ndan genellikle ihmal edilebilir dÃ¼zeyde bir maliyet getirir. Ancak sÄ±kÄ± dÃ¶ngÃ¼lerde (hot path) veya performans kritik kodlarda static dispatch tercih edilmelidir. FarklÄ± tÃ¼rleri heterojen bir koleksiyonda tutma ihtiyacÄ± yoksa, generic kullanmak hem daha hÄ±zlÄ± hem de daha tip-gÃ¼venli bir Ã§Ã¶zÃ¼mdÃ¼r.

### âœ¨ Ä°diomatic Rust: Slice Parametresi

```rust
fn draw_shapes(shapes: &[&dyn Draw]) {
    for shape in shapes.iter() {
        shape.draw();
    }
}
```

`&Vec<&dyn Draw>` yerine `&[&dyn Draw]` (slice) kullanmak daha idiomatiktir. Slice, hem `Vec` hem de dizi referanslarÄ±yla Ã§alÄ±ÅŸabildiÄŸinden fonksiyon daha genel amaÃ§lÄ± hale gelir.

---
